{"name":"quick-pomelo","tagline":"Rapid and robust game server framework based on pomelo and memdb","body":"## Why Quick?\r\n\r\n-  __Performance__ : Data access is mainly based on in process memory, which is extremely fast.\r\n\r\n-  __Scalable__ : System is horizontally scalable, you can simplely add more servers to increase system capacity.\r\n\r\n- __Transaction__ : Full transaction support like traditional database, data consistency is guaranteed.\r\n\r\n- __High Availability__ : Each server is backed by one or more replica, you will never lose any commited data.\r\n\r\n## Prerequisites\r\n\r\n### [Pomelo](https://github.com/NetEase/pomelo)\r\n\r\nQuick-pomelo is based on pomelo, you should first understand the pomelo framework.\r\n\r\n### [MemDB](https://github.com/rain1017/memdb)\r\n\r\nQuick-pomelo use memdb to manage data model and data access, so understanding memdb is required.\r\n\r\n## Documents\r\n\r\n### [The Wiki](https://github.com/rain1017/quick-pomelo/wiki)\r\n### [Demo Game(斗地主)](https://github.com/rain1017/quick-pomelo-demo)\r\n\r\n## Quick Start\r\n\r\n### Start with template\r\n\r\nFirst copy the template to your working directory. The template contains most common skeletons for a quick-pomelo game server.\r\n\r\n### Install dependencies\r\n\r\n* Install [Node.js v0.12](https://nodejs.org/download/)\r\n* Install [Redis](http://redis.io/download)\r\n* Install [MongoDB](https://www.mongodb.org/downloads)\r\n* Install node dependencies\r\n```\r\nnpm install\r\n```\r\n\r\n### Define models\r\n\r\nDefine data models in app/models directory\r\n\r\n```js\r\n// app/models/player.js\r\nmodule.exports = function(app){\r\n\tvar mdbgoose = app.memdb.goose;\r\n\r\n\tvar PlayerSchema = new mdbgoose.Schema({\r\n\t\t_id : {type : String},\r\n\t\tareaId : {type : String, index : true},\r\n\t\tteamId : {type : String, index : true},\r\n\t\tconnectorId : {type : String},\r\n\t\tname : {type : String},\r\n\t}, {collection : 'players'});\r\n\r\n\tmdbgoose.model('Player', PlayerSchema);\r\n};\r\n```\r\n\r\n### Write controllers \r\n\r\nWrite controllers in app/controllers directory\r\n\r\n```js\r\n// app/controllers/player.js\r\nvar Controller = function(app){\r\n\tthis.app = app;\r\n};\r\n\r\nvar proto = Controller.prototype;\r\n\r\nproto.createPlayerAsync = function(opts){\r\n\t// Get model by this.app.models.[model]\r\n\tvar player = new this.app.models.Player(opts);\r\n\tyield player.saveAsync();\r\n};\r\n\r\nproto.removePlayer = function(playerId){\r\n\tvar player = yield this.app.models.Player.findLockedAsync(playerId);\r\n\tif(!player){\r\n\t\tthrow new Error('player not exist');\r\n\t}\r\n\tyield player.removeAsync();\r\n};\r\n\r\nmodule.exports = function(app){\r\n\treturn new Controller(app);\r\n};\r\n```\r\n\r\n### Define routes\r\n\r\nFor each type of server, write a route in app/routes directory.\r\n\r\n```js\r\n// app/routes/player.js\r\nmodule.exports = {\r\n\t// Routing in handler\r\n\thandler : function(session, method, msg){\r\n\t\t// Return a string routing key\r\n\t\t// Same routing key always route to the same backend server.\r\n\t\treturn session.uid || msg.playerId;\r\n\t},\r\n\t// Routing in remote\r\n\tremote : function(routeParam, method, args){\r\n\t\treturn routeParam;\r\n\t}\r\n};\r\n```\r\n\r\n### Write server handlers\r\n\r\nWrite server handlers in app/servers/[server]/handler\r\n\r\n```js\r\n// app/servers/player/playerHandler.js\r\nvar Handler = function(app){\r\n\tthis.app = app;\r\n};\r\n\r\nHandler.prototype.createPlayer = function(msg, session, next){\r\n\t// Get controller by this.app.controllers.[controler]\r\n\treturn this.app.controllers.player.createPlayerAsync(msg.opts)\r\n\t.nodeify(next); \r\n};\r\n\r\nmodule.exports = function(app){\r\n\treturn new Handler(app);\r\n};\r\n```\r\n\r\n### Start server\r\n```\r\nnode app.js\r\n```\r\n\r\n### Well done! Congratulations!\r\n\r\n\r\n## Quick's Philosophy\r\n\r\nA typical realtime game server framework is stateful for the sake of performance, all states is kept in server local memory. However, this approach has significant drawbacks:\r\n\r\n- Any exceptions (may be caused by bugs or unexpected client input) may result in non-consistent state (half-modified dirty data), which is very difficult to recover\r\n- Concurrency control is very difficult to implement\r\n- We must remember which server the data is located, and use rpc to get data, which is error prone.\r\n- In memory data will be lost on server failure, it's very difficult to support HA\r\n\r\nThanks to [memdb](http://memdb.org), quick pomelo un-invent the stateful approach and use a web server like 'MVC' based architecture. All servers become stateless and all states is stored in memdb. You can now get all benefits from a typical stateless web server, without losing performance and scalability of in memory stateful server.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}